温馨提示一定要检查输入法是否为英文 g++编译cpp文件命令：g++ cpp文件名 -o 想要的名称.exe
cout输出cin输入
 main是一个程序入口每个程序都必须有这么一个函数有且仅有一个 main是主函数，只能有一个，其他是辅函数，可以自己命名
1.2 注释作用：在代码中加一些说明和解释，方便自己和其他程序员阅读代码
 单行注释//注释内容 
通常放在一行代码的上方，或者一条语句的末尾，对该代码说明
多行注释/*注释内容*/ 
通常放在一段代码的上方，对该段代码整体说明
（提示：编译器在编译代码时，会忽略注释内容）
1.3 变量
变量存在的意义：方便我们管理内存空间 内存地址编号一般为16进制数 
作用：给一段指定内存空间起名，方便操作这段内存
语法：数据类型 变量名 = 变量初始值；
1.4 常量
作用：用于记录内存中不可更改的数据
C++定义常量两种方式
1.#define 宏常量：#define 常量名 常量值
（通常在文件上方定义，表示一个常量）
2.const修饰的变量 const 数据类型 常量名 = 常量值
（通常在变量定义前加关键字const，修饰该变量为常量，不可修改）
1.5 关键字
作用：关键字是C++中预先保留的单词
（在定义变量和常量时候，不要用关键字）
C++关键字如下
asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch
explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this 
wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try

在命名变量和常量时，不要用c++关键字否则会起歧义
1.6 标识符命名规则
作用：c++规定给标识符（变量 常量）命名时，有一套自己的规则 1.标识符不能为关键字 2.标识符只能由字母数字下划线组成 
3.第一个字符必须为字母或下划线 标识符中字母区分大小写   （建议：给标识符命名时争取做到见名知意的效果方便自己和他人阅读）
2 数据类型 C++规定在创建一个变量和常量时，必须指出相应的数据类型，否则无法给变量分配内存。
  数据类型存在意义：给变量分配合适的内存空间
2.1 数据类型-整型
作用：整型变量表示的是整型类型的数据
C++中能够表示整型的类型有一下几种方式，区别在于所占用内存空间不同：
数据类型	              占用空间	                                                                                                  取值范围
short(短整型)	2字节	                                                                                            (-2^15 ~ 2^15-1)    (-32768~32767)
int(整型)	                4字节	                                                                                            (-2^31 ~ 2^31-1)    (-2147483648~21474836747)
long(长整形)	Windows为4字节，Linux为4字节(32位)，8字节(64位)	                            (-2^31 ~ 2^31-1)    (-2147483648~21474836747)
long long(长长整形)	8字节	                                                                                            (-2^63 ~ 2^63-1)  （-9,223,372,036,854,775,808~9,223,372,036,854,775,807）
超过取值上限就会回到取值下限，没有特殊需求一般用int可以了。
2.2 sizeof关键字
作用：利用sizeof关键字可以统计数据类型所占内存大小
语法：sizeof( 数据类型 / 变量)
整型结论：short<int<=log<=long long
2.3 数据类型-实型（浮点型）
作用：用于表示小数
浮点变量分为两种：
1.单精度float
2.双精度double
两者区别在于表示的有效数字范围不同。
数据类型          占用空间         有效数字范围
float                 4字节               7位有效数字
double              8字节              15~16位有效数字

float类型后面一般在数字后面加一个f   不加f默认认为是double
默认情况下 输出一个小数，会显示出6位有效数字
科学计数法：3e2 =3*10^2    3e-2=3*10^-2=3*0.1^2 
 e后面是正数代表是10^n次方   如果是负数就是0.1^n次方或者10的负次方
例如3e2 =3*10^2                         3e-2=3*10^-2=3*0.1^2   
2.4 数据类型-字符型
 作用：字符型变量用来显示单个字符
语法：char ch = ‘a’
注意1：在显示字符型时，用单引号将字符括起来，不要用双引号
注意2：单引号内只能有一个字符，不可以是字符串
C和C++中字符型变量只占用一个字节。
字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入存储单元
//3.字符型变量常见错误
//char ch2 = "b"; 创建字符型变量时候，要用单引号
// char ch3 = 'ab'; 创建字符型变量时候，单引号内只能有一个字符
//4.字符型变量对应ASCII编码
char ch = 'a'
 cout << (int)ch << endl;//查看a对应的ASCII码
可以直接用ASCII直接给字符型变量赋值
//a-97
//A-65
ASCII码大致由以下两部分组成：
ASCII非打印控制字符：ASCII表上的数据0-31分配给了控制字符，用于控制像打印机等一些外围设备。
ASCII打印字符：数字32-126分配给了能在键盘找到的字符，当查看或打印文档时5就会出现。
2.5 数据类型-转义字符
作用：用于表示一些不能显示出来的ASCII字符
现阶段常用的转义字符有：\n    \\  \t
转义字符	意义	                                                                 ASCLL码值(十进制)
\a	警报(BEL)	                                                                   007
\b	退格(BS) ，将当前位置移到前一列	                   008
\f	换页(FF)，将当前位置移到下页开头	                   012
\n	换行(LF) ，将当前位置移到下一行开头	                   010
\r	回车(CR) ，将当前位置移到本行开头	                   013
\t	水平制表(HT) （占8个空位用于填充）	                   009
\v	垂直制表(VT)	                                                   011
\'	代表一个单引号	                                                   039
\"	代表一个双引号字符	                                                   034
\\	代表一个反斜线字符'''	                                                   092
\?	代表一个问号	                                                   063
\0	空字符(NUL)	                                                   000
\ddd	8进制转义字符，d范围0-7	                                   三位八进制
\xhh	16进制转义字符，十六进制所代表的任意字符	   三位十六进制

\t    作用可以整齐输出数据
2.6 数据类型-字符串型
作用：表示一串字符
两种风格：
C风格字符串：char 变量名[ ] = "字符串值"   注意：C风格要用双括号括起来 注意事项2 等号后面要用双引号 包含起来字符串
C++风格字符串：string 变量名 = "字符串值"
2.7数据类型-布尔类型 bool
作用：布尔数据类型代表真或假 bool类型 只要是非0的值都代表真
bool类型只有两个值：
true  ---真 （本质是1）
false ---假 （本质是0）
bool类型占1个字节大小
本质上1表示真 0表示假
2.8 数据类型-数据的输入
作用：用于从键盘获取数据
关键字：cin
语法：cin >> 变量
bool类型 只要是非0的值都代表真
3.0 运算符
作用：用于执行代码的运算 本章主要讲解以下几类的运算符：
算术运算符  作用：处理四则运算
赋值运算符  作用：用于将表达式的赋值给变量
比较运算符  作用：用于表达式的比较，并返回一个真值或假值
逻辑运算符  作用：用于根据表达式的值返回真值或假值
3.1 算术运算符
运算符                                 术语                                    示例                                                   结果
+                                          正号                                    +3                                                      3
-                                          负号                                      -3                                                       -3
+                                           加                                     10+5                                                   15
-                                            减                                     10-5                                                      5
*                                             乘                                    10*5                                                     50
/                                             除                                    10/5                                                      2
%                                      取模（取余）                          10%3                                                     1
++                                    前置递增                                 a=2;b=++a                                          a=3;b=3
++                                    后置递增                                 a=2;b=a++                                          a=3;b=2
--                                      前置递增                                 a=2;b=--a                                            a=1;b=1
--                                      前置递减                                 a=2;b=a--                                            a=1;b=2
3.1.1 加减乘除
加减在前，先加减再用，加减在后，用完再加减
3.1.2 取余
取余运算符 % 只能用于整数    取余运算本质就是除法取余数
两个数相除，除数不可以为0，所以做不了取余运算
两个小数是不可以做取余运算的
3.1.3 递增递减
前置递增 先让变量加1再进行表达式运算 (a+1)*10
后置递增 先进行表达式运算再让变量加1 (a)*10+1
前置递减 先让变量减1再进行表达式运算 (a-1)*10
后置递减 先进行表达式运算再让变量减1 (a)*10-1
3.2 赋值运算符
作用：用于将表达式的值赋给变量
赋值运算符 = 将右侧的值赋给左侧的变量
运算符                                 术语                                    示例                                                   结果
=                                      赋值                                     a=2;b=3                                          a=2;b=3
+=                                      加等于                                  a=0;a+=2;                                         a=2;
-=                                      减等于                                  a=5;a-=3;                                         a=2;
*=                                      乘等于                                  a=2;a*=2;                                         a=4;	
/=                                      除等于                                  a=4;a/=2;                                         a=2;
%=                                      取余等于                                a=3;a%=2;                                         a=1;
+= 就是让变量先加再赋值       a += 2; // a = a + 2 ;
-= 就是让变量先减再赋值        a -= 2; // a = a - 2 ;
*= 就是让变量先乘再赋值        a *= 2; // a = a * 2 ;
/= 就是让变量先除再赋值      a /= 2; // a = a / 2 ;
%= 就是让变量先取余再赋值    a %= 2; // a = a % 2 ;
3.2比较运算符
作用：用于表达式的比较，并返回一个真值或假值
运算符                                 术语                                    示例                                                   结果
==                                      等于                                     5==5                                                  true（1）
!=                                      不等于                                  5!=5                                                  false （0）
<                                       小于                                     5<5                                                   false （0）
>                                       大于                                     5>5                                                   false （0）
<=                                      小于等于                                 5<=5                                                  true （1）
>=                                      大于等于                                 5>=5                                                  true （1）
运算时需要加括号示例 (a < b) 让先做运算
3.3逻辑运算符
作用：用于根据表达式的值返回真值或假值
运算符                                 术语                                    示例                                                   结果
&&                                      与                                   true&&false                                           false
||                                      或                                   true||false                                           true
!                                       非                                   !true                                                  false
与 &&：两边都为真才是真，只要有一个假就是假   示例 开关串联开关
或 ||：两边都为假才是假，只要有一个真就是真   示例 开关并联开关
非 !：把真变成假，把假变成真  取反
与或非优先级不同，与的优先级高于或，高于非  与>或>非
在c++中除了0都是真
4 程序流结构
C/C++支持以下最基本的三种程序运行结构：
顺序结构：程序按顺序执行，不发生跳转。
选择结构：根据判断条件是否成立，有选择的执行相应功能。
循环结构：根据判断条件是否成立，循环执行某段代码。
4.1 选择结构
4.1.1 if语句
作用执行满足条件的语句
if语句的三种形式
单行格式的if语句      if(条件){}  条件为真执行大括号内容   注意事项，if条件后面不要加分号(；)
多行格式的if语句      if(条件){条件满足执行的语句}else{条件不满足执行的语句}  
多条件的if语句        if(条件1){条件1满足执行的语句}else if(条件2){条件2满足执行的语句}else .....else{都不满足的执行的语句}
还有一种格式，嵌套if语句
嵌套if语句：在if语句中嵌套使用if语句，达到更准确的条件判断 
嵌套if语句示例代码：
int score = 0;
cout << "输入你的高考分数：" << endl;
cin >> score;
//2.显示用户输入的分数
cout << "你输入的分数是：" << score << endl;
//3.判断
if (score > 600) {
	cout << "恭喜你考上一本大学" << endl;
	if (score > 700) {
		cout << "恭喜你考上了北京大学" << endl;
	}
	else if (score > 650) {
		cout << "恭喜你考上了清华大学" << endl;
	}
	else if (score > 600) {
		cout << "恭喜你考上了人民大学" << endl;
	}
}
else if (score > 500) {
	cout << "恭喜你考上了二本大学" << endl;
}
else if (score > 400) {
	cout << "恭喜你考上了三本大学" << endl;
}
else {
	cout << "未考上本科" << endl;
}
4.1.2 三目运算符
作用：通过三目运算符实现简单的判断
语法：表达式1 ? 表达式2 ：表达式3
解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果；
如果表达式1的值为假，执行表达式3，并返回表达式3的结果。
在C++中，三目运算符返回的是变量，可以继续赋值
4.1.3 switch语句
作用：实现多条件分支判断
语法：
switch(表达式){
case 结果1: 执行语句；break；
case 结果2: 执行语句；break；
...
default: 执行语句；break；
}
注意事项：
表达式的结果必须是整型或字符型
case里放的是要和表达式结果对比的值
结果值可以是常量或者常量表达式
break可以省略，但是会带来代码逻辑错误，不建议省略
break; //退出当前分支
case里没有break，代码会向下执行
//if和switch的区别
//switch缺点，表达式的结果必须是整型或者字符型，不可以是一个区间
//switch优点，结构清晰，执行效率高
//if优点，表达式的结果可以是任意类型，可以是区间
//if缺点，执行效率相对低，结构没有switch清晰
4.2 循环结构
4.2.1 while循环
作用：满足循环条件，执行循环语句
语法：while(循环条件) 循环语句;
解释：只要循环条件的结果为真，就执行循环语句
注意事项：循环一定要有退出的条件，否则就是死循环
rand是一个生成随机数的函数
示例：
rand()%100    //生成一个0-99的随机数
srand随机数种子函数
示例：srand((unsigned int)time(NULL));
srand 用于初始化随机数生成器。它接受一个种子值，并根据这个种子值生成一系列伪随机数。
time(NULL) 返回的是一个 time_t 类型的值，表示当前时间的时间戳。将这个时间戳作为种子值传递给 srand 函数，可以确保每次运行程序时，随机数生成器都会从一个不同的起始点开始，从而生成不同的随机数序列。
(unsigned int) 是一个类型转换操作，将 time_t 类型的值转换为 unsigned int 类型。这种转换通常是为了确保传递给 srand 函数的值是无符号整数。
srand 用于初始化随机数生成器。它接受一个种子值，并根据这个种子值生成一系列伪随机数。
4.2.2 do...while循环
作用：满足循环条件，执行循环语句
语法：do{循环语句} while(循环条件);
注意：与while循环不同的是，do...while循环会先执行循环语句，再判断循环条件，只要循环条件的结果为真，就会重复执行循环语句。
解释：do...while循环会先执行循环语句，再判断循环条件，只要循环条件的结果为真，就会重复执行循环语句。
4.2.3 水仙花
获取个位数：num % 10 取余 对数字取模于10就可以拿到个位数
获取十位数：num / 10 % 10 整除除以10再取余就可以拿到十位数
获取百位数：num / 100  整除除以100就可以拿到百位数
4.2.4 for循环
作用：满足循环条件，执行循环语句
语法：for(起始表达式; 循环条件; 循环后操作)
循环语句;
解释：起始表达式先执行一次，然后判断循环条件，如果条件为真，执行循环语句，然后执行循环后操作，再判断循环条件，如果条件为真，继续执行循环语句，直到循环条件为假，退出循环。
for循环的执行顺序：
1. 执行起始表达式
2. 判断循环条件，如果为真，执行循环语句，然后执行循环后操作，再判断循环条件，如果为真，继续执行循环语句，直到循环条件为假，退出循环。
3. 如果循环条件为假，直接退出循环。
4.2.5 嵌套循环
作用：在循环中嵌套使用循环，可以完成一些复杂的重复性操作
语法：外层循环控制行数，内层循环控制列数
示例：
//外层循环
for (int i = 0; i < 10; i++) {
	//内层循环
	for (int j = 0; j < 10; j++) {
		cout << "* ";
	}
	cout << endl;
}
4.3 跳转语句 
4.3.1 break语句
作用：用于跳出选择和循环结构
break使用时机：
出现在switch语句中，作用是终止case并跳出switch	
出现在循环语句中，作用是跳出当前循环语句
出现在嵌套循环中，跳出最近的内层循环
4.3.2 continue 语句
作用：跳过本次循环中余下的代码，直接进行下一次循环
continue使用时机：
出现在循环语句中，作用是跳过本次循环中余下的代码，直接进行下一次循环
4.3.3 goto语句
作用：可以无条件跳转到程序中指定的行
语法：goto 标记;
解释：goto语句可以无条件地跳转到程序中指定的行，标记是一个标识符，后面跟一个冒号。 
示例：
goto FLAG;
cout << "1" << endl;
cout << "2" << endl;
cout << "3" << endl;
FLAG:
cout << "4" << endl;
cout << "5" << endl;
注意事项：
滥用goto语句会导致代码结构混乱，可读性差，建议谨慎使用。
goto语句通常用于处理特殊情况，例如错误处理或跳出多层循环。
goto语句的跳转范围是整个函数，因此需要谨慎使用，以避免跳转到未定义的代码行。
5 数组
5.1 数组定义
作用：用来存储一组相同类型的数据
语法：数据类型 数组名[元素个数];
特点1：数组中存放的数据类型必须统一
特点2：数组是由连续的内存地址组成的
特点3：数组名是数组的标识符，数组名表示整个数组，数组名中存储的是数组首元素的地址
特点4：数组中下标是从0开始的
5.2.1 一维数组
一维数组定义方式
方式1：数据类型 数组名[数组长度];
方式2：数据类型 数组名[数组长度] = {值1，值2...};
方式3：数据类型 数组名[] = {值1，值2...};
5.2.2 一维数组数组名
一维数组名称的用途：
1. 可以统计整个数组在内存中的长度
2. 可以获取数组中某个元素的地址
示例：
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
cout << "整个数组所占内存空间为：" << sizeof(arr) << endl;//整个数组所占内存空间为：40
cout << "数组第一个元素所占内存空间为：" << sizeof(arr[0]) << endl; //数组第一个元素所占内存空间为：4
cout << "数组名arr的值为：" << arr << endl; //数组名arr的值为：0x61feec
cout << "数组名arr的地址为：" << &arr << endl; //数组名arr的地址为：0x61feec
cout << "数组第一个元素的地址为：" << &arr[0] << endl; //数组第一个元素的地址为：0x61feec
cout << "数组第二个元素的地址为：" << &arr[1] << endl; //数组第二个元素的地址为：0x61ff00
cout << "数组第三个元素的地址为：" << &arr[2] << endl; //数组第三个元素的地址为：0x61ff04
5.2.2.1 一维数组案例-元素逆置
起始下标和结束下标位置互换
示例代码
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int start = 0;
int end = sizeof(arr) / sizeof(arr[0]) - 1;
while (start < end) {
	int temp = arr[start];
	arr[start] = arr[end];
	arr[end] = temp;
	start++;
	end--;
}
for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
	cout << arr[i] << endl;
}

5.2.3 冒泡排序
作用：最常用的排序算法，对数组内元素进行排序
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2.对每一对相邻元素做同样的工作，执行完毕后找到最大的元素，它会被放到数组的末尾。
3.重复以上步骤，每次比较次数-1，直到不需要比较。
sizeof(arr)/sizeof(arr[0])是计算数组的长度

for (int j =0; j < sizeof(arr)/sizeof(arr[0]) -1 - i; j++)
这里，内层循环的次数是数组长度-1再减去当前轮数i。
因为每一轮都会将当前未排序部分的最大值放到最后，所以下一轮就可以少比较一次。

比较相邻元素
从数组开头开始，逐一比较相邻的两个元素（例如 arr[0]和arr[1]）。
交换位置
如果前一个元素比后一个大（arr[j] > arr[j+1]），就交换它们的位置。
传递最大值
每一轮完整的遍历后，当前未排序部分的最大值一定会被推到末尾（就像气泡浮到水面）。
缩小范围
下一轮遍历时，忽略已排序好的末尾部分（比较次数减一），重复上述过程直到全部有序。
示例：
int arr[10] = {4,2,8,0,5,7,1,3,9,6};
// 外层循环：控制轮数（n-1轮）
for (int i = 0; i < sizeof(arr)/sizeof(arr[0]) - 1; i++) {
    // 内层循环：相邻元素两两比较（每轮减少一次比较）
    for (int j = 0; j < sizeof(arr)/sizeof(arr[0]) - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {  // 前>后？交换！
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
	cout << arr[i] << endl;
}
5.2.4 数组越界
数组下标从0开始，如果数组下标大于等于数组长度，则下标对应的元素不存在，访问不存在元素会报错
5.3 二维数组
二维数组定义方式
方式1：数据类型 数组名[行数][列数];
方式2：数据类型 数组名[行数][列数] = { {值1，值2...}，{值1，值2...}... };
方式3：数据类型 数组名[行数][列数] = { 值1，值2... };
方式4：数据类型 数组名[][列数] = { 值1，值2... };
5.3.2 二维数组数组名
二维数组名称的用途：
1. 可以统计整个数组在内存中的长度
2. 可以获取数组中某个元素的地址
示例：
int arr[2][3] = 
{ 
	{1,2,3},
	{4,5,6} 
	};
cout << "整个二维数组所占内存空间为：" << sizeof(arr) << endl; //整个二维数组所占内存空间为：24
cout << "二维数组第一行所占内存空间为：" << sizeof(arr[0]) << endl; //二维数组第一行所占内存空间为：12
cout << "二维数组第一行第一个元素所占内存空间为：" << sizeof(arr[0][0]) << endl; //二维数组第一行第一个元素所占内存空间为：4
cout << "二维数组名arr的值为：" << arr << endl; //二维数组名arr的值为：0x61feec
cout << "二维数组名arr的地址为：" << &arr << endl; //二维数组名arr的地址为：0x61feec
cout << "二维数组第一行第一个元素的地址为：" << &arr[0][0] << endl; //二维数组第一行第一个元素的地址为：0x61feec
cout << "二维数组第一行第一个元素的地址为：" << arr[0] << endl; //二维数组第一行第一个元素的地址为：0x61feec
cout << "二维数组第二行第一个元素的地址为：" << arr[1] << endl; //二维数组第二行第一个元素的地址为：0x61ff0c
6.0 函数

6.1 概述
作用：将一段重复使用的代码封装起来，减少重复代码
一个较大的程序，一般分为若干个程序模块，每个模块实现特定的功能。
6.2 函数的定义
函数的定义一般包含五个部分：返回值类型、函数名、参数列表、函数体、返回语句。
返回值类型：指定函数返回值的类型，可以是任何数据类型，包括基本数据类型和复合数据类型。
函数名：用于标识函数，函数名应该具有描述性，以便于理解函数的功能。
参数列表：用于传递给函数的参数，参数列表可以包含零个或多个参数，每个参数由参数类型和参数名组成，参数之间用逗号分隔。
函数体：用于实现函数的具体功能，函数体可以包含任意数量的语句，包括变量声明、条件语句、循环语句等。
返回语句：用于返回函数的结果，返回语句可以包含一个表达式，表达式的值将作为函数的返回值。
语法：返回值类型 函数名(参数列表) { 函数体; 返回语句; }
6.3 函数的调用
函数的调用是指通过函数名和参数来执行函数中的代码。
函数的调用方式：
函数名(参数列表);
函数的调用时机：
当需要执行函数中的代码时，可以通过函数名和参数来调用函数。
函数的调用过程：
当调用函数时，程序会跳转到函数的定义处，执行函数体中的代码，然后返回到调用函数的地方，继续执行后续的代码。
6.4 值传递
值传递是指在调用函数时，将实际参数的值复制一份传递给函数的形式参数，函数内部对形式参数的修改不会影响到实际参数的值。
当不需要返回值时可以使用void 可以省略return
当我们做值传递时，函数形参发生改变不会影响到实参
6.5 常见形式
常见的函数定义形式有：
无参无返：函数没有参数，也没有返回值
示例：void test() { }
调用：test();
有参无返：函数有参数，没有返回值
示例：void test(int a) { }
调用：test(10);
无参有返：函数没有参数，有返回值
示例：int test() { return 10; }
调用：int num = test();
有参有返：函数有参数，有返回值
示例：int test(int a) { return a; }
调用：int num = test(10);
无类型void无法创建创建变量但可以创建函数因为无法分配内存
6.6 函数的声明
作用：告诉编译器函数名称以及如何调用函数，函数的实际主体可以单独定义。
函数声明语法：返回值类型 函数名(参数列表);
函数声明的作用：
1. 告诉编译器函数的名称和参数列表，以便于编译器进行语法检查。
2. 告诉编译器函数的返回值类型，以便于编译器进行类型检查。
声明可以有多次但是函数的定义只能有一次
6.7函数的分文件编写
作用：让代码结构更加清晰
函数分文件编写一般有4个步骤：
1. 创建后缀名为.h的头文件，用于声明函数。语法：函数返回值类型 函数名(参数列表);
2. 创建后缀名为.cpp的源文件，用于定义函数。语法：函数返回值类型 函数名(参数列表) { 函数体; }
3. 在需要调用函数的源文件中包含头文件。
4. 在需要调用函数的源文件中调用函数。
调用方法：#include"头文件名" 在源文件中也要包含头文件
在源文件中包含头文件是为了告诉编译器函数的声明，以便于编译器进行语法检查。
7 指针
7.1 指针的基本概念
指针是一个变量，其值为另一个变量的地址，即，指针变量的值存放的是另一个变量的地址。
指针变量：指针变量是一种特殊的变量，其值是一个内存地址。
指针常量：指针常量是一个固定的内存地址，不能被修改。
指针数组：指针数组是一个数组，其元素是指针变量。
作用：可以通过指针间接访问内存中的数据，实现动态内存分配和内存管理。
内存编号一般从0开始记录，一般用16进制数字表示
可以用指针变量保存地址
7.2 指针的定义和使用
指针的定义语法：数据类型 *指针变量名;
指针的使用语法：指针变量名 = &变量名; 
指针的访问语法：*指针变量名 = 变量值;
指针的解引用语法：变量值 = *指针变量名;
指针的->访问语法：变量值 = 指针变量名->成员名;
指针的[]访问语法：变量值 = 指针变量名[下标];
指针的++和--操作：指针变量名++; 指针变量名--;
指针的加减操作：指针变量名 += n; 指针变量名 -= n;
(int *)表示指向int类型的指针包含两个信息：
1. 指针的类型：int *表示指向int类型的指针。
2. 指针的大小：int *表示指针的大小为4个字节。
示例：
int num =10;
int *p = &num; //指针p指向num的地址
void *voidp = &num; //void *表示指向任意类型的指针，voidp指向num的地址
int *intp = (int*)voidp; //将void *类型的指针转换为int *类型的指针

指针前面加*表示解引用，即获取指针所指向的内存地址中的数据。
7.3 指针所占内存空间
指针类型决定了指针所指向的内存空间的大小。
指针类型	占用内存空间
char	1个字节
short	2个字节
int	4个字节
long	4个字节
long long	8个字节
float	4个字节
double	8个字节
指针类型决定了指针所指向的内存空间的大小，不同类型的指针所占用的内存空间大小不同。
7.4 空指针和野指针
空指针：指针变量指向内存中编号为0的空间 作用：初始化指针变量 空指针指向的内存不可访问 0~255之间的内存编号是系统内存编号，因此不能访问
野指针：指针变量指向的内存空间地址不合法
空指针和野指针的区别：
空指针指向的内存空间是合法的，但是该内存空间没有分配任何数据。
野指针指向的内存空间是非法的，该内存空间可能已经被分配给其他数据，或者该内存空间不存在。
空指针和野指针的危害：
空指针和野指针都可能导致程序崩溃，因为它们指向的内存空间可能已经被其他数据占用，或者该内存空间不存在。
7.5 const修饰指针
const修饰指针有三种情况：
const修饰常量 示例：
int const *p = &a; //指针指向的值不能修改
*p = 100; //错误，不能通过指针修改指向的值
p = &b; //正确，指针可以指向其他变量
int * const p = &a; //指针指向的地址不能修改
p = &b; //错误，不能通过指针修改指向的地址

解释：指针指向的值为常量不可修改，可以改变指针指向的地址
const修饰指针  示例：
int a = 10;
int b = 20;
int * const p = &a; //指针指向的值不能修改
*p = 100; //正确，可以通过指针修改指向的值
p = &b; //错误，不能通过指针修改指向的地址
解释: 指针指向的地址不可修改，可以改变指针指向的值

const修饰指针常量----修饰指针指向的地址和值  示例：
int a = 10;
int b = 20;
const int * const p = &a; //指针指向的地址和值都不能修改
*p = 100; //错误，不能通过指针修改指向的值
p = &b; //错误，不能通过指针修改指向的地址
解释：指针指向的地址和值都不能修改
7.6 指针和数组
利用指针访问数组元素
数组名在大多数情况下可以当作指针来使用，因此可以通过指针来访问数组元素。可以通过指针变量名来访问数组元素。指针变量名[下标] 也可以通过指针变量名加减来访问数组元素。指针变量名++ 指针变量名-- 也可以通过指针变量名加减来访问数组元素。
示例：
int arr[5] = { 1,2,3,4,5 };
int *p = arr; //指针指向数组的第一个元素，即指针p的值为arr[0]的地址
cout << *p << endl; //输出数组的第一个元素
p++; //指针指向数组的第二个元素
cout << *p << endl; //输出数组的第二个元素
指针访问二维数组
二维数组名在大多数情况下可以当作指向一维数组的指针来使用，因此可以通过指针来访问二维数组元素。
示例：
int arr[2][3] = { {1,2,3}, {4,5,6} };
int (*p)[3] = arr; //指针指向长度为3的数组，即指针p的值为arr[0]的地址 int (*p)和int *p是一样的，只是(*p)表示指向一个数组，优先表明为指针而不是数组	
cout << *(*p + 1) << endl; //输出二维数组的第二个元素
p++; //指针指向二维数组的第二个元素
cout << *(*p + 2) << endl; //输出二维数组的第三个元素
7.7 指针与函数
作用：利用指针作为函数参数，修改实参的值。
示例：
void swap(int *p1, int *p2) {
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}
int main() {
	int a = 10;
	int b = 20;
	swap(&a, &b); //通过指针修改实参的值
	cout << "a = " << a << endl; //输出a的值为20
	cout << "b = " << b << endl; //输出b的值为10
	return 0;
}
7.8 冒泡排序和函数和指针案例
案例：
#include <iostream>
using namespace std;

//冒泡排序 参数一：数组首地址 参数二：数组长度  此处arr为指针名不要混淆！！！
void bubbleSort(int *arr, int len) {
	for (int i = 0; i < len - 1; i++) {
		for (int j = 0; j < len - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				int temp = arr[j];
	           arr[j] = arr[j + 1];
	           arr[j + 1] = temp;
			}
		}
	}
}

int printArraay(int *arr, int len) {
	for (int i = 0; i < len; i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}

int main() {
	int arr[] = { 5,4,3,2,1 }; //创建数组
	int len = sizeof(arr) / sizeof(arr[0]); //计算数组长度
	bubbleSort(arr, len); //调用冒泡排序函数 传入数组首地址和数组长度
	printArraay(arr, len); //打印排序后的数组
	
	return 0;
}

8 结构体
8.1 结构体基本概念
结构体是一种自定义的数据类型，可以包含多个不同类型的数据成员。
自定义数据类型就是内置数据类型的集合
使用string输出时需要包含头文件#include<string>

8.2 结构体定义和使用
结构体定义语法：struct 结构体名 { 数据成员列表 };
通过给结构体定义变量的方法有三种：
struct 结构体名 变量名 ; 示例代码：struct Student stu1;
struct 结构体名 变量名 = { 成员1的值, 成员2的值, ... }; 示例：struct Student stu2 = { 18, "Tom" };
struct 结构体名 { 数据成员列表 } 变量名; //定义结构体时顺便定义变量,示例：struct Student { int age; string name; } stu3;
使用：
结构体变量的使用语法：结构体变量名.成员名; 通过.来访问结构体中的成员
结构体变量定义语法：结构体名 变量名; 
结构体变量的使用语法：变量名.成员名;
结构体指针的使用语法：指针变量名->成员名;

8.3 结构体数组
结构体数组是包含多个结构体变量的数组。
定义语法：struct 结构体名 数组名[数组长度] = { {}, {}, ... {} }; 
使用语法：数组名[下标].成员名;
一维数组(以此类推)示例：
#include <iostream>

struct liang {
	int a;
 int b;

};
                    //{1表示a的值，9表示b的值}
struct liang arr[5] = { {1,9}, {2,8}, {3,7}, {4,6}, {5,5} };

int main() {

 
 std::cout<<arr[2].b;

 struct liang  c;



	 
    system("pause");
	return 0;
}
8.4 结构体指针
结构体指针是指向结构体变量的指针。通过指针访问结构体成员时，需要使用->运算符。
定义语法：struct 结构体名 *指针变量名;
使用语法：指针变量名->成员名;
示例：
struct liang {
	int a;
    int b;
	float c;

}; //自定义一个结构体


int main() {

 liang a = {1,2,3.5}; //创建一个结构体变量
 liang *p = &a; //创建一个指向结构体变量的指针
 
    std::cout << p->b << std::endl; //通过指针访问结构体成员


	 
    system("pause");
	return 0;
}
访问一维数组示例：
 liang l1[3] = {
        {1, 2, 3.0},
        {4, 5, 6.0},
        {7, 8, 9.0}
    } ;
	 liang (*p)[3] = &l1;
    std::cout << "l1[0] = " << (*p)[0].c << std::endl;
访问二维数组示例：
liang l1[3][4] ={
 {1,2,3,},
 {5,6,7},
 {9,10,11}
} ;
 liang (*p)[3][4] = &l1;
    std::cout << "l1[0][0] = " << (*p)[0][0].b << std::endl;

8.5 结构体嵌套结构体
作用：结构体成员可以是另一个结构体 例如：每个老师辅导一个学生，学生和老师都是结构体，老师结构体中包含一个学生结构体
定义语法：struct 结构体名 { 数据成员列表; struct 另一个结构体名 变量名; };
使用语法：结构体变量名.另一个结构体变量名.成员名;

8.6 结构体作为函数参数
结构体可以作为函数的参数传递给函数。
传递方式有两种：值传递和指针传递。
值传递：将结构体变量的值复制一份传递给函数，函数内部对结构体变量的修改不会影响到实参的值。
指针传递：将结构体变量的地址传递给函数，函数内部通过指针访问结构体变量，可以修改实参的值。
示例：#include <iostream>

struct liang {
	int a;
    int b;
	float c;

}; //自定义一个结构体

void print(liang l) {
	std::cout << l.a << std::endl;
	std::cout << l.b << std::endl;
	std::cout << l.c << std::endl;
}

void print2(liang *l) {
	std::cout << l->a << std::endl;
	std::cout << l->b << std::endl;
	std::cout << l->c << std::endl;
}

int main() {

 liang a = {1,2,3.5}; //创建一个结构体变量
 print(a); //值传递
 
 print2(&a); //指针传递

    system("pause");
	return 0;
}

8.7 结构体中const的使用场景
作用：用const防止误操作修改结构体成员的值 语法：const 数据类型 成员名;
示例：
#include <iostream>

struct liang {
	int a;
	int b;
	const float c; //用const修饰结构体成员，防止误操作修改结构体成员的值

}; //自定义一个结构体

void print(const liang *l) {
    l->a = 100; //不可以修改，因为指针指向的结构体成员是const
}
int main() {

	liang a = { 1,2,3.5 }; //创建一个结构体变量
	print(&a); //指针传递

	system("pause");
	return 0;
}

C++核心编程
本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓
1 内存分区模型
C++在执行程序时，将内存大方向划分为四个部分：
代码区：存放函数体的二进制代码，由操作系统进行管理的
全局区：存放全局变量和静态变量以及常量，程序结束后由操作系统释放
栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
内存四区意义：
不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程
1.1 程序运行前
在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域
代码区：
存放CPU执行的机器指令
代码区是唯二的两个保存程序数据的内存区域之一
代码区是共享的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可，节省内存空间
代码区是只读的，防止程序意外地修改了机器指令

全局区：存放全局变量和静态变量以及常量，程序结束后由操作系统释放
在函数体中为局部变量分配空间，在栈区分配
在函数体定义外为全局变量分配空间，在全局/静态存储区分配
全局区是唯二的两个保存程序数据的内存区域之一
静态变量：在变量前添加关键字static，称为静态变量
静态变量在程序结束后由操作系统释放
常量：
字符串常量：以空字符结尾的字符数组，被双引号括起来的内容就算是字符串常量
const修饰的变量：coust修饰的全局变量（全局常量），coust修饰的局部变量（局部常量），局部变量不存放在全局区
常量在程序结束后由操作系统释放

1.2程序运行后
栈区：
由编译器自动分配释放，存放函数的参数值，局部变量等
注意事项：
不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

堆区：
由程序员分配释放，若程序员不释放，程序结束时由操作系统回收，
在C++中主要使用new在堆区开辟内存
语法：new 数据类型(初始值)，返回的是16进制内存地址。
示例：
指针本质也是局部变量放在栈区上，指针保存的数据放在堆区
int * fuck()
{
 int * p = new int(10)
return p;

}
//在main中
int *p = fuck()
cout<<*p<<endl;//输出10

1.3 new操作符
C++利用new操作符在堆区开辟数据
堆区开辟的数据，由程序员手动开辟，手动释放，释放使用操作符delete
语法：new 数据类型 示例 int * p = new int(10);
利用new创建的数据会返回该类型的指针
delete 指针变量名;
利用new创建数组：
int *arr = new int[5]; // 创建一个包含5个整数的数组，返回数组首地址
访问语法：指针变量名[下标]。delete[] 指针变量名;

2 引用

引用是C++中一种重要的类型，它为变量提供了一个别名。通过引用，可以使用另一个名字来访问同一个变量。
定义语法：数据类型 &引用名 = 原变量名;
引用需要引用一块合法的内存空间
使用语法：引用名.成员名;
示例：
#include <iostream>

int main() {
	int a = 10;
	int &b = a; // b是a的引用
	b = 20; // 修改b的值，也会修改a的值
	std::cout << a << std::endl; // 输出20
	return 0;
}

2.2 引用的注意事项
引用必须初始化，引用初始化后不能改变
引用作为函数参数，可以简化代码，引用作为函数参数传递时，不会产生副本，可以修改实参的值
引用作为函数的返回值，不要返回局部变量的引用，因为局部变量在函数结束后会被销毁
引用的本质：引用的本质是给变量取了一个别名
错误语法：int &b; // 引用必须初始化
示例：
#include <iostream>

int main() {
	int a = 10;
	int &b = a; // b是a的引用，初始化,引用初始化后不能改变
	b = 20; // 修改b的值，也会修改a的值
	std::cout << a << std::endl; // 输出20
	int c = 30;
	//int &b = c; // 引用初始化后不能改变,报错
	b = c; //这是赋值操作，不是改变引用
	return 0;
}

2.3 引用做函数参数
作用：函数传参时，可以利用引用技术让形参修饰实参
优点：可以简化指针修过实参
语法：返回值类型 函数名(数据类型 &引用名) { 函数体; }
示例：#include <iostream>

void swap(int &a, int &b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {
	int a = 10;
	int b = 20;
	swap(a, b); // 交换a和b的值
	std::cout << "a = " << a << ", b = " << b << std::endl; // 输出a = 20, b = 10
	return 0;
}

2.4 引用做函数返回值
作用：让引用可以作为函数返回值来使用
注意：不要返回局部变量，不要返回局部变量的引用，如果函数返回值是引用就可以作为函数的返回值
用法：函数调用作为左值 
示例：
*/int & test() {
    static int a = 10; // 静态变量，生命周期为整个程序运行期间
    return a; // 返回静态变量的引用
} 也就是test()是a的别名*/
int& test() {
	static int a = 10; // 静态变量，生命周期为整个程序运行期间
	return a; // 返回静态变量的引用
}

int& test2() {
	int a = 10; // 局部变量，生命周期为函数运行期间
	return a; // 返回局部变量的引用，错误
}

int main() {
	int& ref = test(); // 引用作为函数返回值
	test() = 100; // 修改引用的值，也会修改静态变量的值
	std::cout << test() << std::endl; // 输出100
	int& ref2 = test2(); // 引用作为函数返回值，错误，因为test2()返回的是局部变量的引用
	return 0;
}

2.5 引用的本质
本质：引用的本质在c++内部实现是一个指针变量
int& ret = a; // 相当于 int* const ret = &a; 指针常量，指针指向不可改
ret = 100; // 相当于 *ret = 100; 通过指针修改a的值

2.6 常量引用
作用：常量引用主要用于修饰形参，防止误操作
在函数形参列表中，可以用const修饰形参，防止形参修改实参。
示例：
const int& ref = a; // ref是a的常量引用
ref = 20; // 错误，不能通过常量引用修改a的值
const int& ref = 10; // 常量引用可以引用常量,编译器会将代码转换为int temp = 10; const int& ref = temp;
常量引用的本质：常量引用的本质是一个指向常量的指针

3 函数提高
3.1 函数默认参数
在c++中，函数的形参列表中的形参是可以有默认值的，这些默认值称为函数的默认参数。
语法：返回值类型 函数名 (数据类型 形参名 = 默认值) { 函数体; }
传入数据优先级大于默认值，如果传入数据，则使用传入数据，如果未传入数据，则使用默认值
注意事项：
1.如果某个位置的形参有默认值，那么该位置往后，从左到右的所有形参都必须有默认值
2.如果函数声明中有了默认参数，那么函数实现中就不能再出现默认参数，声明和实现只能一个有默认参数